{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Intro","text":"<p>This is a static blog site made with Zensical, Github and Vercel.</p>","path":["Intro"],"tags":[]},{"location":"%E5%B7%A5%E5%85%B7/VS%20C%23%20partial%20property/","level":1,"title":"VS C# partial property","text":"<p>用于 <code>CommunityToolkit.Mvvm</code> 的 partial property Code Snippet。</p>","path":["工具","VS C# partial property"],"tags":["VisualStudio","C#"]},{"location":"%E5%B7%A5%E5%85%B7/VS%20C%23%20partial%20property/#code-snippet","level":2,"title":"Code Snippet","text":"<p>文件路径：<code>%USERPROFILE%\\Documents\\Visual Studio 2022\\Code Snippets\\Visual C#\\My Code Snippets</code></p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;CodeSnippets xmlns=\"http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet\"&gt;\n    &lt;CodeSnippet Format=\"1.0.0\"&gt;\n        &lt;Header&gt;\n            &lt;Title&gt;propp&lt;/Title&gt;\n            &lt;Shortcut&gt;propp&lt;/Shortcut&gt;\n            &lt;Description&gt;Partial public property&lt;/Description&gt;\n            &lt;Author&gt;Orrest&lt;/Author&gt;\n        &lt;/Header&gt;\n        &lt;Snippet&gt;\n            &lt;Declarations&gt;\n                &lt;Literal&gt;\n                    &lt;ID&gt;type&lt;/ID&gt;\n                    &lt;ToolTip&gt;type&lt;/ToolTip&gt;\n                    &lt;Default&gt;Type&lt;/Default&gt;\n                &lt;/Literal&gt;\n                &lt;Literal&gt;\n                    &lt;ID&gt;prop&lt;/ID&gt;\n                    &lt;ToolTip&gt;Property name&lt;/ToolTip&gt;\n                    &lt;Default&gt;MyProperty&lt;/Default&gt;\n                &lt;/Literal&gt;\n            &lt;/Declarations&gt;\n            &lt;Code Language=\"csharp\"&gt;\n                &lt;![CDATA[\n[ObservableProperty]\npublic partial $type$ $prop$ { get; set; }\n        ]]&gt;\n            &lt;/Code&gt;\n        &lt;/Snippet&gt;\n    &lt;/CodeSnippet&gt;\n&lt;/CodeSnippets&gt;\n</code></pre>","path":["工具","VS C# partial property"],"tags":["VisualStudio","C#"]},{"location":"%E5%B7%A5%E5%85%B7/VS%20C%23%20partial%20property/#ref","level":2,"title":"Ref","text":"<p>Walkthrough: Create a code snippet in Visual Studio</p>","path":["工具","VS C# partial property"],"tags":["VisualStudio","C#"]},{"location":"%E7%BC%96%E7%A8%8B/Window%E5%92%8CUseControl%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","level":1,"title":"Window和UseControl生命周期","text":"<p>https://learn.microsoft.com/en-us/dotnet/desktop/wpf/events/object-lifetime-events</p> <ol> <li><code>Window()</code></li> <li><code>Window.InitializeComponent</code></li> <li><code>UserControl()</code></li> <li><code>UserControl.InitializeComponent</code></li> <li><code>UserControl.Initialized</code><ul> <li>元素的属性已被设置</li> <li>构造函数执行完毕</li> <li>子元素已经初始化完成</li> <li>但是 <code>Initialized</code> 事件并不等待所有元素及其子元素被初始化完毕再发出</li> </ul> </li> <li><code>Window.Initialized</code></li> <li><code>UserControl.Loaded</code><ul> <li>When the logical tree that contains the element is complete and connected to a presentation source. The presentation source provides the window handle (HWND) and rendering surface.</li> <li>数据绑定已经完成</li> <li>布局系统已经完成所有渲染所需的计算</li> <li>在最终渲染之前</li> <li><code>Loaded</code> 事件会等待所有逻辑树上的元素都加载完成，自上而下传播，类似 tunneling</li> <li>在 <code>Activated</code> 事件发出后才会发出</li> </ul> </li> <li><code>Window.Loaded</code><ul> <li>需要加载数据的时候</li> </ul> </li> <li><code>Window.ContentRendered</code><ul> <li>需要操作组件的时候</li> </ul> </li> <li><code>Window.Unloaded</code></li> <li><code>UseControl.Unloaded</code><ul> <li>当 <code>Unloaded</code> 事件来到子元素的时候，它的父级可能已经 unset 了，这意味着父级的绑定、资源引用、样式的值已经不正确了</li> </ul> </li> </ol>","path":["编程","Window和UseControl生命周期"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/await/","level":1,"title":"Await","text":"<ul> <li>await 的作用是，将其修饰的表达式后面的流程作为回调加给 task；</li> <li>注册完这个回调，线程就不必再持有当前方法了，因为后面的流程最终将会以回调的方式执行，所以相当于此方法“已经完成”了；     &gt; 划线部分应该不是很准确，涉及到一些我暂不清楚的细节</li> <li>有的描述中会说 “方法会从 await ‘暂停’ 的地方继续执行”，这实际上是因为 <code>await</code> 后的代码作为回调被执行了，与 “暂停” 这个概念没有关系；</li> <li>“暂停” 这个概念的产生或许是因为调试的时候，看起来 <code>await</code> 前后还是在同一个方法里，但前后的流程可能并没有在相同线程中执行（当然也有可能在相同线程中，取决于任务调度）；</li> <li>如果直接调用一个 <code>Task</code> 而不 <code>await</code>，那么它会在线程池线程上执行，但是无法正常捕获异常；</li> </ul> <p>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await</p> <pre><code>public class AwaitOperator\n{\n    public static async Task Main()\n    {\n        Task&lt;int&gt; downloading = DownloadDocsMainPageAsync();\n        Console.WriteLine($\"{nameof(Main)}: Launched downloading.\");\n\n        int bytesLoaded = await downloading;\n        Console.WriteLine($\"{nameof(Main)}: Downloaded {bytesLoaded} bytes.\");\n    }\n\n    private static async Task&lt;int&gt; DownloadDocsMainPageAsync()\n    {\n        Console.WriteLine($\"{nameof(DownloadDocsMainPageAsync)}: About to start downloading.\");\n\n        var client = new HttpClient();\n        byte[] content = await client.GetByteArrayAsync(\"https://learn.microsoft.com/en-us/\");\n\n        Console.WriteLine($\"{nameof(DownloadDocsMainPageAsync)}: Finished downloading.\");\n        return content.Length;\n    }\n}\n// Output similar to:\n// DownloadDocsMainPageAsync: About to start downloading.\n// Main: Launched downloading.\n// DownloadDocsMainPageAsync: Finished downloading.\n// Main: Downloaded 27700 bytes.\n</code></pre> <ul> <li>Task 完成后会通知（实际是以回调的形式执行 await 后的操作）</li> </ul> <p>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#1299-await-expressions</p> <p>看 evaluation 的部分 没看懂</p> <p>https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/ - 如果下一步的开始依赖于上一步的结果，那么异步甚至比同步更慢，因为还额外有线程调度的时间； - 如果几个任务之间是独立的，那么异步执行能够显著提高效率； - 通过分离 Task 的执行和 await 来实现独立任务之间的同时在不同线程上的执行； - 当使用 await 被应用到 task 上时，失败的 task 会抛出异常； - Task.Exception 属性是 System.AggregateException 类型的对象，因为异步任务执行的过程中可能会抛出多个异常； - 如果 Task.Exception 是空的，那么会创建一个 AggregateException 异常，并抛出这集合中的第一个异常； - async/await 在语义上与 ContinueWith 类似，但实际上编译器并没有将 await 表达式直接转换成 ContinueWith。编译器生成优化过的状态机代码，提供相似的运行逻辑。</p> <pre><code>Coffee cup = PourCoffee();\nConsole.WriteLine(\"Coffee is ready\");\n\nTask&lt;Egg&gt; eggsTask = FryEggsAsync(2);\nTask&lt;HashBrown&gt; hashBrownTask = FryHashBrownsAsync(3);\nTask&lt;Toast&gt; toastTask = ToastBreadAsync(2);\n\nToast toast = await toastTask;\nApplyButter(toast);\nApplyJam(toast);\nConsole.WriteLine(\"Toast is ready\");\nJuice oj = PourOJ();\nConsole.WriteLine(\"Oj is ready\");\n\nEgg eggs = await eggsTask;\nConsole.WriteLine(\"Eggs are ready\");\nHashBrown hashBrown = await hashBrownTask;\nConsole.WriteLine(\"Hash browns are ready\");\n\nConsole.WriteLine(\"Breakfast is ready!\");\n</code></pre>","path":["编程","Await"],"tags":["C#","Threading"]},{"location":"%E7%BC%96%E7%A8%8B/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82/","level":1,"title":"依赖注入容器中注册工厂","text":"","path":["编程","依赖注入容器中注册工厂"],"tags":["DI","Microsoft.Extensions.DependencyInjection"]},{"location":"%E7%BC%96%E7%A8%8B/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82/#addfactory","level":2,"title":"扩展方法 AddFactory","text":"<pre><code>// Source - https://stackoverflow.com/a/57430389\n// Posted by Martin Brandl\n// Retrieved 2025-12-01, License - CC BY-SA 4.0\n\npublic static class IServiceCollectionExtension\n{\n    public static IServiceCollection AddFactory&lt;TService, TServiceImplementation&gt;(this IServiceCollection serviceCollection) \n        where TService : class\n        where TServiceImplementation : class, TService\n    {\n        return serviceCollection\n            // 注册需要通过工厂被初始化的服务\n            .AddTransient&lt;TService, TServiceImplementation&gt;()\n            // 注册工厂函数\n            .AddSingleton&lt;Func&lt;TService&gt;&gt;(sp =&gt; sp.GetRequiredService&lt;TService&gt;);\n    }\n}\n</code></pre>","path":["编程","依赖注入容器中注册工厂"],"tags":["DI","Microsoft.Extensions.DependencyInjection"]},{"location":"%E7%BC%96%E7%A8%8B/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82/#_1","level":2,"title":"手动工厂","text":"<p>假设需要传入参数到工厂函数中：</p> <pre><code>sc.AddSingleton&lt;Func&lt;string, IInterface&gt;&gt;(sp =&gt;\n{\n    return parameter =&gt;\n    {\n        var logger = sp.GetRequiredService&lt;ILogger&lt;Implementation&gt;&gt;();\n        IInterface impl = new Implementation(parameter, logger);\n\n        return impl;\n    };\n});\n</code></pre> <p>注入：</p> <pre><code>ctor(Func&lt;string, IInterface&gt; factory) { /*...*/ }\n</code></pre> <p>注意仅这个 <code>Func</code> 委托是单例的，实际上每次调用 <code>factory()</code> 时，都返回新的实例，生命周期上是 <code>transient</code> 的。</p> <p>如果需要一个“单例工厂”的话，那直接 <code>AddSingleton</code> 就可以了，单例的依赖也一定是单例的（即使是被提升的）</p>","path":["编程","依赖注入容器中注册工厂"],"tags":["DI","Microsoft.Extensions.DependencyInjection"]},{"location":"%E7%BC%96%E7%A8%8B/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82/#ref","level":2,"title":"Ref","text":"<ul> <li>StackOverflow: AddFactory</li> <li>Github: dotnet/runtime</li> </ul>","path":["编程","依赖注入容器中注册工厂"],"tags":["DI","Microsoft.Extensions.DependencyInjection"]},{"location":"%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/","level":1,"title":"异步音频播放","text":"","path":["编程","异步音频播放"],"tags":["C#","Threading","Audio"]},{"location":"%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/#1-taskcompletionsource","level":2,"title":"1 TaskCompletionSource","text":"<p>官方的 demo 中使用的是控制台程序，并通过 <code>Console.ReadKey</code> 来避免程序结束。</p> <p>在 WPF 中像这样把所有步骤写在一个方法中时会出现一个问题，尽管程序没有结束，但是函数释放了。</p> <p>由于 <code>Play</code> 不是一个阻塞方法，因此函数在结束后会释放其中所持有的资源，导致“点击了按钮，但是没有播放音频文件”的现象。</p> <p>解决的方法是使用 <code>TaskCompletionSource</code> 并结合 <code>await</code>，这样使得 <code>player</code> 依赖上了 <code>TaskCompletionSource</code> 变量，<code>TaskCompletionSource</code> 又要在 <code>player</code> 的回调中设置值并返回，因此音乐能够完整地播放完毕，同时按钮的 <code>IsEnabled</code> 状态也正常了。</p> <p>这种情况下 <code>player</code> 的生命周期被变相地延长了。</p> <pre><code>public sealed partial class PlayerViewModel : ObservableRecipient\n{\n    [RelayCommand]\n    public async Task Play()\n    {\n        // Initialize the audio engine with the MiniAudio backend.\n        using var audioEngine = new MiniAudioEngine();\n\n        // Find the default playback device.\n        var defaultPlaybackDevice = audioEngine\n            .PlaybackDevices\n            .FirstOrDefault(d =&gt; d.IsDefault);\n\n        if (defaultPlaybackDevice.Id == IntPtr.Zero)\n        {\n            Messenger.Send(\"No default playback device found.\", Channels.TOAST);\n            return;\n        }\n\n        // The audio format for processing. We'll use 32-bit float, which is standard for processing.\n        // The data provider will handle decoding the source file to this format.\n        var audioFormat = new AudioFormat\n        {\n            Format = SampleFormat.F32,\n            SampleRate = 48000,\n            Channels = 2,\n        };\n\n        // Initialize the playback device. This manages the connection to the physical audio hardware.\n        // The 'using' statement ensures it's properly disposed of.\n        using var device = audioEngine\n            .InitializePlaybackDevice(defaultPlaybackDevice, audioFormat);\n\n        // Create a data provider for the audio file.\n        // Replace \"path/to/your/audiofile.wav\" with the actual path to your audio file.\n        using var dataProvider = new StreamDataProvider(\n            audioEngine,\n            audioFormat,\n            File.OpenRead(\"Files/file_example_MP3_1MG.mp3\")\n        );\n\n        // Create a SoundPlayer, linking the engine, format, and data provider.\n        // The player is also IDisposable.\n        using var player = new SoundPlayer(audioEngine, audioFormat, dataProvider);\n\n        // Add the player to the device's master mixer to route its audio for playback.\n        device.MasterMixer.AddComponent(player);\n\n        // Start the device. This opens the audio stream to the hardware.\n        device.Start();\n\n        var tcs = new TaskCompletionSource&lt;bool&gt;();\n        player.PlaybackEnded += (s, e) =&gt; tcs.SetResult(true);\n\n        // Start playback.\n        player.Play();\n\n        await tcs.Task;\n    }\n}\n</code></pre>","path":["编程","异步音频播放"],"tags":["C#","Threading","Audio"]},{"location":"%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/#2","level":3,"title":"2 一种验证","text":"<p>如果像这样使函数所使用的系统资源随 viewModel 生命周期，音频文件也能够播放至结束。</p> <p>不过按钮的 <code>IsEnabled</code> 状态并不符合预期，播放命令在点击时就释放了，<code>player.Play</code> 能够播放完毕是因为它在后台线程上触发了播放任务，所需要的资源也未随着函数结束而释放，因此能够播放完毕。</p> <pre><code>public sealed partial class PlayerViewModel : ObservableRecipient\n{\n    private AudioEngine audioEngine = new MiniAudioEngine();\n    private AudioFormat audioFormat;\n    private AudioPlaybackDevice device;\n    private StreamDataProvider dataProvider;\n    private SoundPlayer player;\n\n    public PlayerViewModel()\n    {\n        var defaultPlaybackDevice = audioEngine.PlaybackDevices.FirstOrDefault(d =&gt; d.IsDefault);\n\n        if (defaultPlaybackDevice.Id == IntPtr.Zero)\n        {\n            Messenger.Send(\"No default playback device found.\", Channels.TOAST);\n            return;\n        }\n\n        audioFormat = new AudioFormat\n        {\n            Format = SampleFormat.F32,\n            SampleRate = 48000,\n            Channels = 2,\n        };\n\n        device = audioEngine.InitializePlaybackDevice(defaultPlaybackDevice, audioFormat);\n\n        dataProvider = new StreamDataProvider(\n            audioEngine,\n            audioFormat,\n            File.OpenRead(\"Files/file_example_MP3_1MG.mp3\")\n        );\n\n        player = new SoundPlayer(audioEngine, audioFormat, dataProvider);\n    }\n\n    [RelayCommand]\n    public void Play()\n    {\n        device.MasterMixer.AddComponent(player);\n\n        device.Start();\n\n        player.Play();\n    }\n}\n</code></pre>","path":["编程","异步音频播放"],"tags":["C#","Threading","Audio"]},{"location":"%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/#ref","level":2,"title":"Ref","text":"<ol> <li>SoundFlow example</li> </ol>","path":["编程","异步音频播放"],"tags":["C#","Threading","Audio"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/","level":1,"title":"自定义 MessageBox","text":"","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#messagebox","level":2,"title":"MessageBox","text":"<ol> <li>创建一个 Window</li> <li>窗口设置<ul> <li><code>ResizeMode</code>: 用于定义右上角的窗体按钮</li> <li><code>ShowInTaskbar</code>：不在系统任务栏显示</li> <li><code>WindowStyle</code>：窗口风格，默认 <code>SingleBorderWindow</code></li> </ul> </li> <li>依赖属性<ul> <li><code>ButtonCommandProperty</code>：只读的依赖属性，用于处理按钮点击后的结果</li> <li><code>ConfirmText</code>、<code>RefuseText</code>、<code>CancelText</code>：分别对应含义为肯定的、否定的和取消的按钮，根据相应属性是否有内容来决定是否显示相应的按钮</li> <li><code>Title</code>、<code>Caption</code>：需要显示的信息</li> </ul> </li> </ol> <p>遇到过一个问题，一开始直接使用控件继承来的 <code>Content</code> 属性，但是它实际上是 <code>Window</code> 下的默认属性，会导致窗口中的内容被赋值的字符串替代</p>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#showdialogasync","level":2,"title":"ShowDialogAsync","text":"<p>使用 <code>TaskCompletionSource</code> 来将同步的方法转换为异步，本质上是将手动编写回调方法的操作交给了编译器：</p> <pre><code>protected TaskCompletionSource&lt;MessageBoxResult&gt;? TaskCompletionSource { get; set; }\n</code></pre> <p><code>base.ShowDialog()</code> 仍然需要在主线程：</p> <pre><code>    public async Task&lt;MessageBoxResult&gt; ShowDialogAsync(\n        CancellationToken cancellationToken = default\n    )\n    {\n        TaskCompletionSource = new TaskCompletionSource&lt;MessageBoxResult&gt;();\n\n        CancellationTokenRegistration tokenRegistration = cancellationToken.Register(\n            o =&gt; TaskCompletionSource.TrySetCanceled((CancellationToken)o!),\n            cancellationToken\n        );\n\n        try\n        {\n            base.ShowDialog();\n\n            return await TaskCompletionSource.Task;\n        }\n        finally\n        {\n#if NET6_0_OR_GREATER\n            await tokenRegistration.DisposeAsync();\n#else\n            tokenRegistration.Dispose();\n#endif\n        }\n    }\n</code></pre> <p>在离开窗口时异步地设置结果：</p> <pre><code>private void OnButtonClick(string buttonName)\n{\n    var result = buttonName switch\n    {\n        CONFIRM =&gt; MessageBoxResult.Yes,\n        REFUSE =&gt; MessageBoxResult.No,\n        CANCEL =&gt; MessageBoxResult.Cancel,\n        _ =&gt; throw new ApplicationException(),\n    };\n\n    _ = TaskCompletionSource?.TrySetResult(result);\n\n    base.Close();\n}\n\nprotected override void OnClosing(CancelEventArgs e)\n{\n    base.OnClosing(e);\n\n    if (e.Cancel)\n    {\n        return;\n    }\n\n    _ = TaskCompletionSource?.TrySetResult(MessageBoxResult.Cancel);\n}\n</code></pre>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_1","level":2,"title":"使用","text":"<p>属性的设置及方法的调用都需要在主线程：</p> <pre><code>[RelayCommand]\nprivate async Task ShowOnUiThreadAndContinueOnNonUiThread()\n{\n    var result = await System.Windows.Application.Current.Dispatcher.Invoke(() =&gt;\n    {\n        var box = new MessageBox()\n        {\n            Title = \"Create on UI Thread\",\n            Caption = \"Set properties on UI thread\",\n            ConfirmText = \"Yes\",\n            RefuseText = \"No\",\n            WindowStartupLocation = System.Windows.WindowStartupLocation.CenterScreen,\n        };\n\n        var t = box.ShowDialogAsync();\n\n        return t;\n    });\n\n    await Task.Run(() =&gt;\n    {\n        if (result == System.Windows.MessageBoxResult.Yes)\n        {\n            Messenger.Send(\"I'm OK here.\", nameof(MainViewModel));\n        }\n        else if (result == System.Windows.MessageBoxResult.No)\n        {\n            Messenger.Send(\"Cancelled.\", nameof(MainViewModel));\n        }\n    });\n}\n</code></pre>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_2","level":2,"title":"理解","text":"<p>编译器对 <code>await</code> 的操作是将其后的代码片段转换成类似 <code>Task.Continuation</code> 的逻辑，本质上也是一种类似回调的逻辑，只不过是隐式由编译器实现的。</p> <p><code>base.ShowDialog</code> -&gt; 窗口关闭时返回 -&gt; 在 <code>OnClosing</code> 或 <code>OnButtonClick</code> 中设置结果 -&gt; <code>TaskCompletionSource.Task get</code> -&gt; <code>ShowDialogAsync</code> 结束返回</p>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_3","level":2,"title":"代码","text":"<p>Github: CustomizedMessageBox</p>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/","level":1,"title":"自定义组件","text":"<ul> <li>UserControl：适用于粒度较大，需要自己的 ViewModel 的组件；</li> <li>Custom Control：适用于粒度小，无额外状态或状态较少的组件；</li> </ul>","path":["编程","自定义组件"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/#usercontrol","level":2,"title":"UserControl","text":"<ul> <li>形式上是 .xaml.cs + .xaml；</li> <li>多个组件的组合，一般用于页面内容（或者用 Page）；</li> <li>一般有自己对应的 viewModel；</li> </ul> <p>总的来说适用于粒度比较大，其中引用多个无状态组件，但是自己本身有状态（viewModel）的组件情况。</p> <p>实现步骤：</p> <ol> <li>创建 UserControl（.xaml.cs, .xaml 文件）；</li> <li>创建对应的 ViewModel；</li> <li>在 ViewModel 中声明用于绑定的属性；</li> <li>在 .xaml 中进行绑定；</li> </ol> <p>如果情况比较简单，不使用 ViewModel，也可以在 .xaml.cs 中声明依赖属性，将 DataContext 设为控件自己。</p> <p>使用依赖属性时，如果仅有一个“主属性”，其它属性都是由主属性计算得来，那么在声明依赖属性时，利用 PropertyMetadata 中的 onPropertyChanged 回调进行其它依赖于它的属性的计算即可。</p>","path":["编程","自定义组件"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/#custom-control","level":2,"title":"Custom control","text":"<ol> <li>可以直接手动创建 .cs 文件，继承 System.Windows.Controls.Control（不需要 .xaml 文件了）;</li> <li> <p>声明组件的 Style（对于控件样式使用 TemplateBinding，对于自定义的依赖属性，使用 Binding）；     <pre><code>&lt;Style TargetType=\"{x:Type local:MyCustomControl}\"&gt;\n    &lt;Setter Property=\"Template\"&gt;\n        &lt;Setter.Value&gt;\n            &lt;ControlTemplate TargetType=\"{x:Type local:MyCustomControl}\"&gt;\n                &lt;Border Padding=\"10\" Background=\"LightGray\"&gt;\n                    &lt;TextBlock Text=\"{TemplateBinding Title}\" FontSize=\"16\"/&gt;\n                &lt;/Border&gt;\n            &lt;/ControlTemplate&gt;\n        &lt;/Setter.Value&gt;\n    &lt;/Setter&gt;\n&lt;/Style&gt;\n</code></pre></p> </li> <li> <p>在 App.xaml 中（或者所需控件中）添加相关控件所在的资源字典；</p> </li> </ol>","path":["编程","自定义组件"],"tags":["WPF","Frontend"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/","level":1,"title":"表示“转换”的单词","text":"","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#words","level":2,"title":"Words","text":"","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#convey","level":3,"title":"Convey","text":"<p>及物动词</p> <ul> <li>让某人知道或领会其他人的感情或想法；</li> <li>把人或者物从一个地方运输到另一处；</li> <li>【法律】将房屋产权或资产从一方转让给另一方；</li> </ul> <p>Please <code>convey</code> our condolences to the family. 请向家人表达我们的哀悼。</p> <p>An irrigation system was built to <code>convey</code> water from the river to the rice fields high up in the mountain. 通过灌溉系统，将水从河流输送到高山上的稻田。</p> <p>Mr Wu <code>conveyed</code> his entire estate to a charity. 吴先生把他所有的资产转给了一个慈善机构。</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#convert","level":3,"title":"Convert","text":"<p>及物动词/名词</p> <ul> <li>v. 转换、改变、改装，如单位转换；</li> <li>v. 思想或信仰的改变；</li> <li>n. 指改变了信仰的人；</li> </ul> <p>We need more space in the house, is it possible to <code>convert</code> the garage <code>into</code> a bedroom? 我们需要更多的空间，可不可以把车库改成一个卧房？</p> <p>I wasn’t interested in Korean dramas before, but my cousin has <code>converted</code> me. 我以前对韩剧没什么兴趣，不过我的表妹改变了我的看法。</p> <p>I wasn’t convinced about dishwashers, but now I am a <code>convert</code>. 我以前不相信洗碗机有什么用，但是现在我彻底转变想法了 。</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#transform","level":3,"title":"Transform","text":"<p>一般是及物动词</p> <ul> <li>完全地、彻底地改变一个人或一个事物的外表或性质（一般是向好的方面）；</li> </ul> <p>The plan is to <code>transform</code> the area <code>into</code> a tourist attraction. 这个计划是把这个地区开发成一个旅游景点。</p> <p>In the film, a plain young girl was <code>transformed</code> <code>into</code> a star. 在电影里，一名普通的女孩儿摇身一变成了明星。</p> <p>Smartphone technology has <code>transformed</code> the way we communicate with each other. 智能手机技术完全改变了人们交流的方式。</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#divert","level":3,"title":"Divert","text":"<ul> <li>使事物或人转变方向；</li> <li>改变事物的用途；</li> <li>转移或分散注意力；</li> <li>提供娱乐（很少使用）；</li> </ul> <p>Due to fog, our plane was <code>diverted</code> to another airport. 受大雾影响，我们的飞机被转到了另一个机场。</p> <p>The telecom companies have set very high charges for <code>diverting</code> international calls. 电话公司设定了非常高的国际电话转接费。</p> <p>It’s against law to <code>divert</code> public funds for private use. 挪用公款来支付个人开支是违法行为。</p> <p>The directors tried to <code>divert</code> attention away from the real issues in the work place. 公司领导试图把大家的注意力从公司里实际的问题上转移。</p> <p>The kids managed to <code>divert</code> themselves with a set of DVDs. 小朋友们找到了一些 DVD 碟片，可以自我娱乐了。</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#ref","level":2,"title":"Ref","text":"<p>Convey, convert, transform 和 divert 四个含有“转换”意思的单词</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]}]}