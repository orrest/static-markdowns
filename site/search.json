{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Orrest's","text":"<p>This is a static blog site made with Zensical, Github and Vercel.</p>","path":["Orrest's"],"tags":[]},{"location":"%E7%BC%96%E7%A8%8B/Window%E5%92%8CUseControl%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","level":1,"title":"Window和UseControl生命周期","text":"<p>https://learn.microsoft.com/en-us/dotnet/desktop/wpf/events/object-lifetime-events</p> <ol> <li><code>Window()</code></li> <li><code>Window.InitializeComponent</code></li> <li><code>UserControl()</code></li> <li><code>UserControl.InitializeComponent</code></li> <li><code>UserControl.Initialized</code><ul> <li>元素的属性已被设置</li> <li>构造函数执行完毕</li> <li>子元素已经初始化完成</li> <li>但是 <code>Initialized</code> 事件并不等待所有元素及其子元素被初始化完毕再发出</li> </ul> </li> <li><code>Window.Initialized</code></li> <li><code>UserControl.Loaded</code><ul> <li>When the logical tree that contains the element is complete and connected to a presentation source. The presentation source provides the window handle (HWND) and rendering surface.</li> <li>数据绑定已经完成</li> <li>布局系统已经完成所有渲染所需的计算</li> <li>在最终渲染之前</li> <li><code>Loaded</code> 事件会等待所有逻辑树上的元素都加载完成，自上而下传播，类似 tunneling</li> <li>在 <code>Activated</code> 事件发出后才会发出</li> </ul> </li> <li><code>Window.Loaded</code><ul> <li>需要加载数据的时候</li> </ul> </li> <li><code>Window.ContentRendered</code><ul> <li>需要操作组件的时候</li> </ul> </li> <li><code>Window.Unloaded</code></li> <li><code>UseControl.Unloaded</code><ul> <li>当 <code>Unloaded</code> 事件来到子元素的时候，它的父级可能已经 unset 了，这意味着父级的绑定、资源引用、样式的值已经不正确了</li> </ul> </li> </ol>","path":["编程","Window和UseControl生命周期"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/","level":1,"title":"自定义 MessageBox","text":"","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#messagebox","level":2,"title":"MessageBox","text":"<ol> <li>创建一个 Window</li> <li>窗口设置<ul> <li><code>ResizeMode</code>: 用于定义右上角的窗体按钮</li> <li><code>ShowInTaskbar</code>：不在系统任务栏显示</li> <li><code>WindowStyle</code>：窗口风格，默认 <code>SingleBorderWindow</code></li> </ul> </li> <li>依赖属性<ul> <li><code>ButtonCommandProperty</code>：只读的依赖属性，用于处理按钮点击后的结果</li> <li><code>ConfirmText</code>、<code>RefuseText</code>、<code>CancelText</code>：分别对应含义为肯定的、否定的和取消的按钮，根据相应属性是否有内容来决定是否显示相应的按钮</li> <li><code>Title</code>、<code>Caption</code>：需要显示的信息</li> </ul> </li> </ol> <p>遇到过一个问题，一开始直接使用控件继承来的 <code>Content</code> 属性，但是它实际上是 <code>Window</code> 下的默认属性，会导致窗口中的内容被赋值的字符串替代</p>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#showdialogasync","level":2,"title":"ShowDialogAsync","text":"<p>使用 <code>TaskCompletionSource</code> 来将同步的方法转换为异步，本质上是将手动编写回调方法的操作交给了编译器：</p> <pre><code>protected TaskCompletionSource&lt;MessageBoxResult&gt;? TaskCompletionSource { get; set; }\n</code></pre> <p><code>base.ShowDialog()</code> 仍然需要在主线程：</p> <pre><code>    public async Task&lt;MessageBoxResult&gt; ShowDialogAsync(\n        CancellationToken cancellationToken = default\n    )\n    {\n        TaskCompletionSource = new TaskCompletionSource&lt;MessageBoxResult&gt;();\n\n        CancellationTokenRegistration tokenRegistration = cancellationToken.Register(\n            o =&gt; TaskCompletionSource.TrySetCanceled((CancellationToken)o!),\n            cancellationToken\n        );\n\n        try\n        {\n            base.ShowDialog();\n\n            return await TaskCompletionSource.Task;\n        }\n        finally\n        {\n#if NET6_0_OR_GREATER\n            await tokenRegistration.DisposeAsync();\n#else\n            tokenRegistration.Dispose();\n#endif\n        }\n    }\n</code></pre> <p>在离开窗口时异步地设置结果：</p> <pre><code>private void OnButtonClick(string buttonName)\n{\n    var result = buttonName switch\n    {\n        CONFIRM =&gt; MessageBoxResult.Yes,\n        REFUSE =&gt; MessageBoxResult.No,\n        CANCEL =&gt; MessageBoxResult.Cancel,\n        _ =&gt; throw new ApplicationException(),\n    };\n\n    _ = TaskCompletionSource?.TrySetResult(result);\n\n    base.Close();\n}\n\nprotected override void OnClosing(CancelEventArgs e)\n{\n    base.OnClosing(e);\n\n    if (e.Cancel)\n    {\n        return;\n    }\n\n    _ = TaskCompletionSource?.TrySetResult(MessageBoxResult.Cancel);\n}\n</code></pre>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_1","level":2,"title":"使用","text":"<p>属性的设置及方法的调用都需要在主线程：</p> <pre><code>[RelayCommand]\nprivate async Task ShowOnUiThreadAndContinueOnNonUiThread()\n{\n    var result = await System.Windows.Application.Current.Dispatcher.Invoke(() =&gt;\n    {\n        var box = new MessageBox()\n        {\n            Title = \"Create on UI Thread\",\n            Caption = \"Set properties on UI thread\",\n            ConfirmText = \"Yes\",\n            RefuseText = \"No\",\n            WindowStartupLocation = System.Windows.WindowStartupLocation.CenterScreen,\n        };\n\n        var t = box.ShowDialogAsync();\n\n        return t;\n    });\n\n    await Task.Run(() =&gt;\n    {\n        if (result == System.Windows.MessageBoxResult.Yes)\n        {\n            Messenger.Send(\"I'm OK here.\", nameof(MainViewModel));\n        }\n        else if (result == System.Windows.MessageBoxResult.No)\n        {\n            Messenger.Send(\"Cancelled.\", nameof(MainViewModel));\n        }\n    });\n}\n</code></pre>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_2","level":2,"title":"理解","text":"<p>编译器对 <code>await</code> 的操作是将其后的代码片段转换成类似 <code>Task.Continuation</code> 的逻辑，本质上也是一种类似回调的逻辑，只不过是隐式由编译器实现的。</p> <p><code>base.ShowDialog</code> -&gt; 窗口关闭时返回 -&gt; 在 <code>OnClosing</code> 或 <code>OnButtonClick</code> 中设置结果 -&gt; <code>TaskCompletionSource.Task get</code> -&gt; <code>ShowDialogAsync</code> 结束返回</p>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_3","level":2,"title":"代码","text":"<p>Github: CustomizedMessageBox</p>","path":["编程","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/","level":1,"title":"自定义组件","text":"<ul> <li>UserControl：适用于粒度较大，需要自己的 ViewModel 的组件；</li> <li>Custom Control：适用于粒度小，无额外状态或状态较少的组件；</li> </ul>","path":["编程","自定义组件"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/#usercontrol","level":2,"title":"UserControl","text":"<ul> <li>形式上是 .xaml.cs + .xaml；</li> <li>多个组件的组合，一般用于页面内容（或者用 Page）；</li> <li>一般有自己对应的 viewModel；</li> </ul> <p>总的来说适用于粒度比较大，其中引用多个无状态组件，但是自己本身有状态（viewModel）的组件情况。</p> <p>实现步骤：</p> <ol> <li>创建 UserControl（.xaml.cs, .xaml 文件）；</li> <li>创建对应的 ViewModel；</li> <li>在 ViewModel 中声明用于绑定的属性；</li> <li>在 .xaml 中进行绑定；</li> </ol> <p>如果情况比较简单，不使用 ViewModel，也可以在 .xaml.cs 中声明依赖属性，将 DataContext 设为控件自己。</p> <p>使用依赖属性时，如果仅有一个“主属性”，其它属性都是由主属性计算得来，那么在声明依赖属性时，利用 PropertyMetadata 中的 onPropertyChanged 回调进行其它依赖于它的属性的计算即可。</p>","path":["编程","自定义组件"],"tags":["WPF","Frontend"]},{"location":"%E7%BC%96%E7%A8%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/#custom-control","level":2,"title":"Custom control","text":"<ol> <li>可以直接手动创建 .cs 文件，继承 System.Windows.Controls.Control（不需要 .xaml 文件了）;</li> <li> <p>声明组件的 Style（对于控件样式使用 TemplateBinding，对于自定义的依赖属性，使用 Binding）；     <pre><code>&lt;Style TargetType=\"{x:Type local:MyCustomControl}\"&gt;\n    &lt;Setter Property=\"Template\"&gt;\n        &lt;Setter.Value&gt;\n            &lt;ControlTemplate TargetType=\"{x:Type local:MyCustomControl}\"&gt;\n                &lt;Border Padding=\"10\" Background=\"LightGray\"&gt;\n                    &lt;TextBlock Text=\"{TemplateBinding Title}\" FontSize=\"16\"/&gt;\n                &lt;/Border&gt;\n            &lt;/ControlTemplate&gt;\n        &lt;/Setter.Value&gt;\n    &lt;/Setter&gt;\n&lt;/Style&gt;\n</code></pre></p> </li> <li> <p>在 App.xaml 中（或者所需控件中）添加相关控件所在的资源字典；</p> </li> </ol>","path":["编程","自定义组件"],"tags":["WPF","Frontend"]}]}