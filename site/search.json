{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Intro","text":"<p>This is a static blog site made with Zensical, Github and Vercel.</p>","path":["Intro"],"tags":[]},{"location":"Links/","level":1,"title":"Links","text":"<ul> <li>Articles about Aspire from engineer at Microsoft</li> </ul>","path":["Links"],"tags":["Links"]},{"location":"WPF/Prism%E7%9A%84%E5%AF%BC%E8%88%AA/","level":1,"title":"Prism的导航","text":"","path":["WPF","Prism的导航"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/Prism%E7%9A%84%E5%AF%BC%E8%88%AA/#_1","level":2,"title":"问题","text":"<p>从 DI 容器中获得实例的时候，需要泛型或者 Type 实例，如果直接通过类型或者 <code>typeof</code> 关键字获取，都会使得当前项目依赖于所需要导航到的视图所属的项目（同一个项目内是无所谓，但一旦开始模块化这就会造成耦合）。</p> <p>在 <code>简单导航1</code> 一文中，通过使用中介的枚举变量来解耦这种导航间的依赖关系，但还是需要手动维护 <code>switch case</code>。</p> <p>在 Prism 中，可以直接通过字符串来进行视图的定位，从而导航：</p> <pre><code>_regionManager.RequestNavigate(RegionNames.ContentRegion, \"DashboardView\");\n</code></pre> <p>那么它是如何实现从字符串到视图之间的映射的？</p>","path":["WPF","Prism的导航"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/Prism%E7%9A%84%E5%AF%BC%E8%88%AA/#_2","level":2,"title":"从字符串到视图","text":"<p>在 Prism 中，定义了 <code>ViewRegistration</code> 类来保存视图的名字以及视图相关的信息。</p> <pre><code>namespace Prism.Mvvm;\n\n /// &lt;summary&gt;\n/// Represents information about a registered view.\n/// &lt;/summary&gt;\npublic record ViewRegistration\n{\n    /// &lt;summary&gt;\n    /// Gets the type of view this registration represents (Page, Region, or Dialog).\n    /// &lt;/summary&gt;\n    public ViewType Type { get; init; }\n\n    /// &lt;summary&gt;\n    /// Gets the type of the view class associated with this registration.\n    /// &lt;/summary&gt;\n    public Type View { get; init; }\n\n    /// &lt;summary&gt;\n    /// Gets the type of the view model associated with this registration, if any.\n    /// &lt;/summary&gt;\n    public Type ViewModel { get; init; }\n\n    /// &lt;summary&gt;\n    /// Gets the unique name used to identify this view registration.\n    /// &lt;/summary&gt;\n    public string Name { get; init; }\n}\n</code></pre> <pre><code>namespace Prism.Mvvm;\n\n/// &lt;summary&gt;\n/// Enumerates the different types of views supported by the framework.\n/// &lt;/summary&gt;\npublic enum ViewType\n{\n    /// &lt;summary&gt;\n    /// Unknown view type.\n    /// &lt;/summary&gt;\n    Unknown,\n\n    /// &lt;summary&gt;\n    /// Represents a full-screen page or window.\n    /// &lt;/summary&gt;\n    Page,\n\n    /// &lt;summary&gt;\n    /// Represents a reusable region within a view.\n    /// &lt;/summary&gt;\n    Region,\n\n    /// &lt;summary&gt;\n    /// Represents a modal dialog or popup window.\n    /// &lt;/summary&gt;\n    Dialog,\n}\n</code></pre>","path":["WPF","Prism的导航"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/Prism%E7%9A%84%E5%AF%BC%E8%88%AA/#registerfornavigation","level":2,"title":"RegisterForNavigation","text":"<p>注册视图的同时也注册了这个字符串-视图关系。</p> <pre><code>22    public static IServiceCollection RegisterForNavigation(this IServiceCollection services, Type view, Type viewModel, string name = null)\n23    {\n24        if (view is null)\n25            throw new ArgumentNullException(nameof(view));\n26\n27        if (!view.IsAssignableTo(PageType))\n28            throw new InvalidOperationException($\"The view type '{view.FullName}' is not a type of Page.\");\n29\n30        if (string.IsNullOrEmpty(name))\n31            name = view.Name;\n32\n33        services.AddSingleton(new ViewRegistration\n34            {\n35                Type = ViewType.Page,\n36                Name = name,\n37                View = view,\n38                ViewModel = viewModel\n39            })\n40            .AddTransient(view);\n41\n42        if (viewModel != null)\n43            services.AddTransient(viewModel);\n44\n45        return services;\n46    }\n</code></pre>","path":["WPF","Prism的导航"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/Prism%E7%9A%84%E5%AF%BC%E8%88%AA/#_3","level":2,"title":"根据字符串创建视图","text":"<p><code>ViewRegistryBase</code> 是用于注册和创建视图的。</p> <p>DI 容器会自动收集所有相同类型的实例作为一个集合，注入 <code>ViewRegistration</code> 集合：</p> <pre><code>protected ViewRegistryBase(ViewType registryType, IEnumerable&lt;ViewRegistration&gt; registrations)\n{\n    _registrations = registrations;\n    _registryType = registryType;\n}\n</code></pre> <p>然后就可以根据 name 筛选出所需 ViewRegistration 的实例，并通过其中的 type 等从容器中取得对应的视图实例</p> <pre><code>public object? CreateView(IContainerProvider container, string name)\n{\n    try\n    {\n        var registration = GetRegistration(name) ?? throw new KeyNotFoundException($\"No view with the name '{name}' has been registered\");\n        var view = container.Resolve(registration.View) as TBaseView;\n        // ...\n</code></pre> <pre><code>/// &lt;summary&gt;\n/// Gets the registration information for a view with the specified name, or null if not found.\n/// &lt;/summary&gt;\n/// &lt;param name=\"name\"&gt;The name of the view to look up.&lt;/param&gt;\n/// &lt;returns&gt;The view registration object, or null if not found.&lt;/returns&gt;\nprotected ViewRegistration? GetRegistration(string name) =&gt;\n    Registrations.LastOrDefault(viewRegistration =&gt; viewRegistration.Name == name);\n</code></pre>","path":["WPF","Prism的导航"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/Prism%E7%9A%84%E5%AF%BC%E8%88%AA/#_4","level":2,"title":"总结","text":"<p>Prism 中主要通过向 DI 容器中注册 <code>ViewRegistration</code> 实例，达到能够在 DI 容器中获得字符串到类型映射的目的，同时 DI 容器又能够通过类型获得注册的视图实例。</p>","path":["WPF","Prism的导航"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/Window%E5%92%8CUseControl%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","level":1,"title":"Window和UseControl生命周期","text":"<p>https://learn.microsoft.com/en-us/dotnet/desktop/wpf/events/object-lifetime-events</p> <ol> <li><code>Window()</code></li> <li><code>Window.InitializeComponent</code></li> <li><code>UserControl()</code></li> <li><code>UserControl.InitializeComponent</code></li> <li><code>UserControl.Initialized</code><ul> <li>元素的属性已被设置</li> <li>构造函数执行完毕</li> <li>子元素已经初始化完成</li> <li>但是 <code>Initialized</code> 事件并不等待所有元素及其子元素被初始化完毕再发出</li> </ul> </li> <li><code>Window.Initialized</code></li> <li><code>UserControl.Loaded</code><ul> <li>When the logical tree that contains the element is complete and connected to a presentation source. The presentation source provides the window handle (HWND) and rendering surface.</li> <li>数据绑定已经完成</li> <li>布局系统已经完成所有渲染所需的计算</li> <li>在最终渲染之前</li> <li><code>Loaded</code> 事件会等待所有逻辑树上的元素都加载完成，自上而下传播，类似 tunneling</li> <li>在 <code>Activated</code> 事件发出后才会发出</li> </ul> </li> <li><code>Window.Loaded</code><ul> <li>需要加载数据的时候</li> </ul> </li> <li><code>Window.ContentRendered</code><ul> <li>需要操作组件的时候</li> </ul> </li> <li><code>Window.Unloaded</code></li> <li><code>UseControl.Unloaded</code><ul> <li>当 <code>Unloaded</code> 事件来到子元素的时候，它的父级可能已经 unset 了，这意味着父级的绑定、资源引用、样式的值已经不正确了</li> </ul> </li> </ol>","path":["WPF","Window和UseControl生命周期"],"tags":["WPF","Frontend"]},{"location":"WPF/await/","level":1,"title":"Await","text":"<ul> <li>await 的作用是，将其修饰的表达式后面的流程作为回调加给 task；</li> <li>注册完这个回调，线程就不必再持有当前方法了，因为后面的流程最终将会以回调的方式执行，所以相当于此方法“已经完成”了；     &gt; 划线部分应该不是很准确，涉及到一些我暂不清楚的细节</li> <li>有的描述中会说 “方法会从 await ‘暂停’ 的地方继续执行”，这实际上是因为 <code>await</code> 后的代码作为回调被执行了，与 “暂停” 这个概念没有关系；</li> <li>“暂停” 这个概念的产生或许是因为调试的时候，看起来 <code>await</code> 前后还是在同一个方法里，但前后的流程可能并没有在相同线程中执行（当然也有可能在相同线程中，取决于任务调度）；</li> <li>如果直接调用一个 <code>Task</code> 而不 <code>await</code>，那么它会在线程池线程上执行，但是无法正常捕获异常；</li> </ul> <p>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await</p> <pre><code>public class AwaitOperator\n{\n    public static async Task Main()\n    {\n        Task&lt;int&gt; downloading = DownloadDocsMainPageAsync();\n        Console.WriteLine($\"{nameof(Main)}: Launched downloading.\");\n\n        int bytesLoaded = await downloading;\n        Console.WriteLine($\"{nameof(Main)}: Downloaded {bytesLoaded} bytes.\");\n    }\n\n    private static async Task&lt;int&gt; DownloadDocsMainPageAsync()\n    {\n        Console.WriteLine($\"{nameof(DownloadDocsMainPageAsync)}: About to start downloading.\");\n\n        var client = new HttpClient();\n        byte[] content = await client.GetByteArrayAsync(\"https://learn.microsoft.com/en-us/\");\n\n        Console.WriteLine($\"{nameof(DownloadDocsMainPageAsync)}: Finished downloading.\");\n        return content.Length;\n    }\n}\n// Output similar to:\n// DownloadDocsMainPageAsync: About to start downloading.\n// Main: Launched downloading.\n// DownloadDocsMainPageAsync: Finished downloading.\n// Main: Downloaded 27700 bytes.\n</code></pre> <ul> <li>Task 完成后会通知（实际是以回调的形式执行 await 后的操作）</li> </ul> <p>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#1299-await-expressions</p> <p>看 evaluation 的部分 没看懂</p> <p>https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/ - 如果下一步的开始依赖于上一步的结果，那么异步甚至比同步更慢，因为还额外有线程调度的时间； - 如果几个任务之间是独立的，那么异步执行能够显著提高效率； - 通过分离 Task 的执行和 await 来实现独立任务之间的同时在不同线程上的执行； - 当使用 await 被应用到 task 上时，失败的 task 会抛出异常； - Task.Exception 属性是 System.AggregateException 类型的对象，因为异步任务执行的过程中可能会抛出多个异常； - 如果 Task.Exception 是空的，那么会创建一个 AggregateException 异常，并抛出这集合中的第一个异常； - async/await 在语义上与 ContinueWith 类似，但实际上编译器并没有将 await 表达式直接转换成 ContinueWith。编译器生成优化过的状态机代码，提供相似的运行逻辑。</p> <pre><code>Coffee cup = PourCoffee();\nConsole.WriteLine(\"Coffee is ready\");\n\nTask&lt;Egg&gt; eggsTask = FryEggsAsync(2);\nTask&lt;HashBrown&gt; hashBrownTask = FryHashBrownsAsync(3);\nTask&lt;Toast&gt; toastTask = ToastBreadAsync(2);\n\nToast toast = await toastTask;\nApplyButter(toast);\nApplyJam(toast);\nConsole.WriteLine(\"Toast is ready\");\nJuice oj = PourOJ();\nConsole.WriteLine(\"Oj is ready\");\n\nEgg eggs = await eggsTask;\nConsole.WriteLine(\"Eggs are ready\");\nHashBrown hashBrown = await hashBrownTask;\nConsole.WriteLine(\"Hash browns are ready\");\n\nConsole.WriteLine(\"Breakfast is ready!\");\n</code></pre>","path":["WPF","Await"],"tags":["C#","Threading"]},{"location":"WPF/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82/","level":1,"title":"依赖注入容器中注册工厂","text":"","path":["WPF","依赖注入容器中注册工厂"],"tags":["DI","Microsoft.Extensions.DependencyInjection"]},{"location":"WPF/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82/#addfactory","level":2,"title":"扩展方法 AddFactory","text":"<pre><code>// Source - https://stackoverflow.com/a/57430389\n// Posted by Martin Brandl\n// Retrieved 2025-12-01, License - CC BY-SA 4.0\n\npublic static class IServiceCollectionExtension\n{\n    public static IServiceCollection AddFactory&lt;TService, TServiceImplementation&gt;(this IServiceCollection serviceCollection) \n        where TService : class\n        where TServiceImplementation : class, TService\n    {\n        return serviceCollection\n            // 注册需要通过工厂被初始化的服务\n            .AddTransient&lt;TService, TServiceImplementation&gt;()\n            // 注册工厂函数\n            .AddSingleton&lt;Func&lt;TService&gt;&gt;(sp =&gt; sp.GetRequiredService&lt;TService&gt;);\n    }\n}\n</code></pre>","path":["WPF","依赖注入容器中注册工厂"],"tags":["DI","Microsoft.Extensions.DependencyInjection"]},{"location":"WPF/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82/#_1","level":2,"title":"手动工厂","text":"<p>假设需要传入参数到工厂函数中：</p> <pre><code>sc.AddSingleton&lt;Func&lt;string, IInterface&gt;&gt;(sp =&gt;\n{\n    return parameter =&gt;\n    {\n        var logger = sp.GetRequiredService&lt;ILogger&lt;Implementation&gt;&gt;();\n        IInterface impl = new Implementation(parameter, logger);\n\n        return impl;\n    };\n});\n</code></pre> <p>注入：</p> <pre><code>ctor(Func&lt;string, IInterface&gt; factory) { /*...*/ }\n</code></pre> <p>注意仅这个 <code>Func</code> 委托是单例的，实际上每次调用 <code>factory()</code> 时，都返回新的实例，生命周期上是 <code>transient</code> 的。</p> <p>如果需要一个“单例工厂”的话，那直接 <code>AddSingleton</code> 就可以了，单例的依赖也一定是单例的（即使是被提升的）</p>","path":["WPF","依赖注入容器中注册工厂"],"tags":["DI","Microsoft.Extensions.DependencyInjection"]},{"location":"WPF/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82/#ref","level":2,"title":"Ref","text":"<ul> <li>StackOverflow: AddFactory</li> <li>Github: dotnet/runtime</li> </ul>","path":["WPF","依赖注入容器中注册工厂"],"tags":["DI","Microsoft.Extensions.DependencyInjection"]},{"location":"WPF/%E5%BC%82%E6%AD%A5%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/","level":1,"title":"异步音频播放","text":"","path":["WPF","异步音频播放"],"tags":["C#","Threading","Audio"]},{"location":"WPF/%E5%BC%82%E6%AD%A5%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/#1-taskcompletionsource","level":2,"title":"1 TaskCompletionSource","text":"<p>官方的 demo 中使用的是控制台程序，并通过 <code>Console.ReadKey</code> 来避免程序结束。</p> <p>在 WPF 中像这样把所有步骤写在一个方法中时会出现一个问题，尽管程序没有结束，但是函数释放了。</p> <p>由于 <code>Play</code> 不是一个阻塞方法，因此函数在结束后会释放其中所持有的资源，导致“点击了按钮，但是没有播放音频文件”的现象。</p> <p>解决的方法是使用 <code>TaskCompletionSource</code> 并结合 <code>await</code>，这样使得 <code>player</code> 依赖上了 <code>TaskCompletionSource</code> 变量，<code>TaskCompletionSource</code> 又要在 <code>player</code> 的回调中设置值并返回，因此音乐能够完整地播放完毕，同时按钮的 <code>IsEnabled</code> 状态也正常了。</p> <p>这种情况下 <code>player</code> 的生命周期被变相地延长了。</p> <pre><code>public sealed partial class PlayerViewModel : ObservableRecipient\n{\n    [RelayCommand]\n    public async Task Play()\n    {\n        // Initialize the audio engine with the MiniAudio backend.\n        using var audioEngine = new MiniAudioEngine();\n\n        // Find the default playback device.\n        var defaultPlaybackDevice = audioEngine\n            .PlaybackDevices\n            .FirstOrDefault(d =&gt; d.IsDefault);\n\n        if (defaultPlaybackDevice.Id == IntPtr.Zero)\n        {\n            Messenger.Send(\"No default playback device found.\", Channels.TOAST);\n            return;\n        }\n\n        // The audio format for processing. We'll use 32-bit float, which is standard for processing.\n        // The data provider will handle decoding the source file to this format.\n        var audioFormat = new AudioFormat\n        {\n            Format = SampleFormat.F32,\n            SampleRate = 48000,\n            Channels = 2,\n        };\n\n        // Initialize the playback device. This manages the connection to the physical audio hardware.\n        // The 'using' statement ensures it's properly disposed of.\n        using var device = audioEngine\n            .InitializePlaybackDevice(defaultPlaybackDevice, audioFormat);\n\n        // Create a data provider for the audio file.\n        // Replace \"path/to/your/audiofile.wav\" with the actual path to your audio file.\n        using var dataProvider = new StreamDataProvider(\n            audioEngine,\n            audioFormat,\n            File.OpenRead(\"Files/file_example_MP3_1MG.mp3\")\n        );\n\n        // Create a SoundPlayer, linking the engine, format, and data provider.\n        // The player is also IDisposable.\n        using var player = new SoundPlayer(audioEngine, audioFormat, dataProvider);\n\n        // Add the player to the device's master mixer to route its audio for playback.\n        device.MasterMixer.AddComponent(player);\n\n        // Start the device. This opens the audio stream to the hardware.\n        device.Start();\n\n        var tcs = new TaskCompletionSource&lt;bool&gt;();\n        player.PlaybackEnded += (s, e) =&gt; tcs.SetResult(true);\n\n        // Start playback.\n        player.Play();\n\n        await tcs.Task;\n    }\n}\n</code></pre>","path":["WPF","异步音频播放"],"tags":["C#","Threading","Audio"]},{"location":"WPF/%E5%BC%82%E6%AD%A5%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/#2","level":2,"title":"2 一种验证","text":"<p>如果像这样使函数所使用的系统资源随 viewModel 生命周期，音频文件也能够播放至结束。</p> <p>不过按钮的 <code>IsEnabled</code> 状态并不符合预期，播放命令在点击时就释放了，<code>player.Play</code> 能够播放完毕是因为它在后台线程上触发了播放任务，所需要的资源也未随着函数结束而释放，因此能够播放完毕。</p> <pre><code>public sealed partial class PlayerViewModel : ObservableRecipient\n{\n    private AudioEngine audioEngine = new MiniAudioEngine();\n    private AudioFormat audioFormat;\n    private AudioPlaybackDevice device;\n    private StreamDataProvider dataProvider;\n    private SoundPlayer player;\n\n    public PlayerViewModel()\n    {\n        var defaultPlaybackDevice = audioEngine.PlaybackDevices.FirstOrDefault(d =&gt; d.IsDefault);\n\n        if (defaultPlaybackDevice.Id == IntPtr.Zero)\n        {\n            Messenger.Send(\"No default playback device found.\", Channels.TOAST);\n            return;\n        }\n\n        audioFormat = new AudioFormat\n        {\n            Format = SampleFormat.F32,\n            SampleRate = 48000,\n            Channels = 2,\n        };\n\n        device = audioEngine.InitializePlaybackDevice(defaultPlaybackDevice, audioFormat);\n\n        dataProvider = new StreamDataProvider(\n            audioEngine,\n            audioFormat,\n            File.OpenRead(\"Files/file_example_MP3_1MG.mp3\")\n        );\n\n        player = new SoundPlayer(audioEngine, audioFormat, dataProvider);\n    }\n\n    [RelayCommand]\n    public void Play()\n    {\n        device.MasterMixer.AddComponent(player);\n\n        device.Start();\n\n        player.Play();\n    }\n}\n</code></pre>","path":["WPF","异步音频播放"],"tags":["C#","Threading","Audio"]},{"location":"WPF/%E5%BC%82%E6%AD%A5%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/#ref","level":2,"title":"Ref","text":"<ol> <li>SoundFlow example</li> </ol>","path":["WPF","异步音频播放"],"tags":["C#","Threading","Audio"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA1/","level":1,"title":"简单导航1","text":"<p>依赖于 <code>CommunityToolkit.Mvvm</code> 的简单导航。</p>","path":["WPF","简单导航1"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA1/#code","level":2,"title":"Code","text":"<pre><code>public partial class MainViewModel : ObservableRecipient\n{\n    private readonly IServiceProvider serviceProvider;\n\n    [ObservableProperty]\n    public partial ObservableCollection&lt;ViewItem&gt; ViewItems { get; set; }\n\n    [ObservableProperty]\n    public partial string ToastMessage { get; set; } = string.Empty;\n\n    [ObservableProperty]\n    public partial ViewItem? SelectedView { get; set; }\n\n    [ObservableProperty]\n    public partial object? ContentView { get; set; }\n\n    public MainViewModel(IServiceProvider serviceProvider)\n    {\n        this.serviceProvider = serviceProvider;\n\n        ViewItems =\n        [\n            new() { Name = \"Visibility\", View = ViewName.VISIBILITY },\n            new() { Name = \"Grid Splitter\", View = ViewName.GRID_SPLLITER },\n            new() { Name = \"Customized TabItem\", View = ViewName.CUSTOMIZED_TAB_ITEM },\n            new() { Name = \"Customized MessageBox\", View = ViewName.MESSAGE_BOX },\n            new() { Name = \"DragDrop\", View = ViewName.DRAG_DROP },\n            new() { Name = \"ProgressMask\", View = ViewName.PROGRESS },\n            new() { Name = nameof(DesignTimeDataView), View = ViewName.DESIGN_DATA },\n            new() { Name = \"Validation\", View = ViewName.VALIDATION },\n            new() { Name = \"Audio\", View = ViewName.PLAYER }\n        ];\n\n        Messenger.Register&lt;NavigationMessage, string&gt;(\n            this,\n            Channels.NAVIGATION,\n            (r, m) =&gt;\n            {\n                Navigate(m);\n            }\n        );\n\n        Messenger.Register&lt;string, string&gt;(\n            this,\n            Channels.TOAST,\n            (r, m) =&gt;\n            {\n                ToastMessage = m;\n            }\n        );\n    }\n\n    private void Navigate(NavigationMessage m)\n    {\n        var view = m.View;\n\n        object? instance = null;\n        switch (view)\n        {\n            case ViewName.VISIBILITY:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;VisibilityView&gt;();\n                break;\n            }\n\n            case ViewName.GRID_SPLLITER:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;GridSplitterView&gt;();\n                break;\n            }\n            case ViewName.CUSTOMIZED_TAB_ITEM:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;CustomizedTabItemView&gt;();\n                break;\n            }\n            case ViewName.MESSAGE_BOX:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;MessageBoxView&gt;();\n                break;\n            }\n            case ViewName.DRAG_DROP:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;DragDropView&gt;();\n                break;\n            }\n            case ViewName.PROGRESS:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;ProgressMaskView&gt;();\n                break;\n            }\n            case ViewName.DESIGN_DATA:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;DesignTimeDataView&gt;();\n                break;\n            }\n            case ViewName.VALIDATION:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;ValidationView&gt;();\n                break;\n            }\n            case ViewName.PLAYER:\n            {\n                instance = this.serviceProvider.GetRequiredService&lt;PlayerView&gt;();\n                break;\n            }\n        }\n\n        ContentView = instance;\n    }\n\n    partial void OnSelectedViewChanged(ViewItem? value)\n    {\n        if (value is null)\n        {\n            return;\n        }\n\n        Messenger.Send(new NavigationMessage() { View = value.View }, Channels.NAVIGATION);\n    }\n}\n</code></pre>","path":["WPF","简单导航1"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA1/#ref","level":2,"title":"Ref","text":"<p>Github: orrest/Tests</p>","path":["WPF","简单导航1"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA2/","level":1,"title":"简单导航2","text":"","path":["WPF","简单导航2"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA2/#_1","level":2,"title":"简单","text":"<ul> <li>不借用字符串去定位 ContentControl;</li> <li>注册视图时同时注册视图名-视图的关系，这样可以直接使用视图名进行导航；</li> </ul>","path":["WPF","简单导航2"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA2/#_2","level":2,"title":"导航","text":"<ul> <li>使用的是 MSDI；</li> <li>在 viewModel 中绑定 ContentControl 的 Content 属性；</li> <li>依赖 <code>CommunityToolkit.Mvvm</code> 进行消息通知；</li> <li>通过视图名称查找视图实例；</li> </ul>","path":["WPF","简单导航2"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA2/#_3","level":3,"title":"注册","text":"<pre><code>public static class DependencyInjectionExtensions\n{\n    public static IHostBuilder ConfigureViews(this IHostBuilder hostBuilder)\n    {\n        return hostBuilder.ConfigureServices(\n            (sc) =&gt;\n            {\n                sc.AddSingleton&lt;MainWindow&gt;();\n                sc.AddSingleton&lt;MainViewModel&gt;();\n\n                // navigation\n                sc.AddForNavigation(typeof(VisibilityView), typeof(VisibilityViewModel));\n                sc.AddForNavigation(typeof(GridSplitterView), typeof(GridSplitterViewModel));\n                sc.AddForNavigation(typeof(CustomizedTabItemView), typeof(CustomizedTabItemViewModel));\n                sc.AddForNavigation(typeof(MessageBoxView), typeof(MessageBoxViewModel));\n                sc.AddForNavigation(typeof(DragDropView), typeof(DragDropViewModel));\n                sc.AddForNavigation(typeof(ProgressMaskView), typeof(ProgressMaskViewModel));\n                sc.AddForNavigation(typeof(DesignTimeDataView), typeof(DesignTimeDataViewModel));\n                sc.AddForNavigation(typeof(ValidationView), typeof(ValidationViewModel));\n                sc.AddForNavigation(typeof(PlayerView), typeof(PlayerViewModel));\n            }\n        );\n    }\n\n    public static void AddForNavigation(this IServiceCollection sc, Type view, Type viewModel)\n    {\n        var viewItem = new ViewRegistryItem()\n        {\n            Name = view.Name,\n            ViewType = view,\n            ViewModelType = viewModel\n        };\n\n        sc.AddSingleton(viewItem);\n\n        sc.AddTransient(view);\n        sc.AddTransient(viewModel);\n    }\n}\n</code></pre>","path":["WPF","简单导航2"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA2/#_4","level":3,"title":"发出导航请求","text":"<pre><code>partial void OnSelectedViewChanged(ViewItem? value)\n{\n    if (value is null)\n    {\n        return;\n    }\n\n    Messenger.Send(value.ViewName, Channels.NAVIGATION);\n}\n</code></pre>","path":["WPF","简单导航2"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA2/#_5","level":3,"title":"处理导航请求","text":"<pre><code>private void Navigate(string viewName)\n{\n    var views = this.serviceProvider.GetService&lt;IEnumerable&lt;ViewRegistryItem&gt;&gt;();\n    var viewItem = views?.LastOrDefault(v =&gt; v.Name == viewName);\n    if (viewItem is null)\n    {\n        return;\n    }\n\n    var view = this.serviceProvider.GetService(viewItem.ViewType);\n    if (view is null)\n    {\n        return;\n    }\n\n    ContentView = view;\n}\n</code></pre>","path":["WPF","简单导航2"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA2/#_6","level":2,"title":"总结","text":"<ul> <li>可以使用字符串来避免导航时需要视图类型的耦合；</li> <li>在视图注册了的情况下，后续新增导航视图时只需，1. 添加导航目录；2. 发送请求导航消息；</li> <li>如何导航嵌套得很深的话，在多个 viewModel 中可能会重复实现相似的逻辑，考虑创建导航管理类，将导航的职责提取出来；</li> </ul>","path":["WPF","简单导航2"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E7%AE%80%E5%8D%95%E5%AF%BC%E8%88%AA2/#ref","level":2,"title":"Ref","text":"<p>Github: orrest/Tests</p>","path":["WPF","简单导航2"],"tags":["WPF","Frontend","Navigation"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/","level":1,"title":"自定义 MessageBox","text":"","path":["WPF","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#messagebox","level":2,"title":"MessageBox","text":"<ol> <li>创建一个 Window</li> <li>窗口设置<ul> <li><code>ResizeMode</code>: 用于定义右上角的窗体按钮</li> <li><code>ShowInTaskbar</code>：不在系统任务栏显示</li> <li><code>WindowStyle</code>：窗口风格，默认 <code>SingleBorderWindow</code></li> </ul> </li> <li>依赖属性<ul> <li><code>ButtonCommandProperty</code>：只读的依赖属性，用于处理按钮点击后的结果</li> <li><code>ConfirmText</code>、<code>RefuseText</code>、<code>CancelText</code>：分别对应含义为肯定的、否定的和取消的按钮，根据相应属性是否有内容来决定是否显示相应的按钮</li> <li><code>Title</code>、<code>Caption</code>：需要显示的信息</li> </ul> </li> </ol> <p>遇到过一个问题，一开始直接使用控件继承来的 <code>Content</code> 属性，但是它实际上是 <code>Window</code> 下的默认属性，会导致窗口中的内容被赋值的字符串替代</p>","path":["WPF","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#showdialogasync","level":2,"title":"ShowDialogAsync","text":"<p>使用 <code>TaskCompletionSource</code> 来将同步的方法转换为异步，本质上是将手动编写回调方法的操作交给了编译器：</p> <pre><code>protected TaskCompletionSource&lt;MessageBoxResult&gt;? TaskCompletionSource { get; set; }\n</code></pre> <p><code>base.ShowDialog()</code> 仍然需要在主线程：</p> <pre><code>    public async Task&lt;MessageBoxResult&gt; ShowDialogAsync(\n        CancellationToken cancellationToken = default\n    )\n    {\n        TaskCompletionSource = new TaskCompletionSource&lt;MessageBoxResult&gt;();\n\n        CancellationTokenRegistration tokenRegistration = cancellationToken.Register(\n            o =&gt; TaskCompletionSource.TrySetCanceled((CancellationToken)o!),\n            cancellationToken\n        );\n\n        try\n        {\n            base.ShowDialog();\n\n            return await TaskCompletionSource.Task;\n        }\n        finally\n        {\n#if NET6_0_OR_GREATER\n            await tokenRegistration.DisposeAsync();\n#else\n            tokenRegistration.Dispose();\n#endif\n        }\n    }\n</code></pre> <p>在离开窗口时异步地设置结果：</p> <pre><code>private void OnButtonClick(string buttonName)\n{\n    var result = buttonName switch\n    {\n        CONFIRM =&gt; MessageBoxResult.Yes,\n        REFUSE =&gt; MessageBoxResult.No,\n        CANCEL =&gt; MessageBoxResult.Cancel,\n        _ =&gt; throw new ApplicationException(),\n    };\n\n    _ = TaskCompletionSource?.TrySetResult(result);\n\n    base.Close();\n}\n\nprotected override void OnClosing(CancelEventArgs e)\n{\n    base.OnClosing(e);\n\n    if (e.Cancel)\n    {\n        return;\n    }\n\n    _ = TaskCompletionSource?.TrySetResult(MessageBoxResult.Cancel);\n}\n</code></pre>","path":["WPF","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_1","level":2,"title":"使用","text":"<p>属性的设置及方法的调用都需要在主线程：</p> <pre><code>[RelayCommand]\nprivate async Task ShowOnUiThreadAndContinueOnNonUiThread()\n{\n    var result = await System.Windows.Application.Current.Dispatcher.Invoke(() =&gt;\n    {\n        var box = new MessageBox()\n        {\n            Title = \"Create on UI Thread\",\n            Caption = \"Set properties on UI thread\",\n            ConfirmText = \"Yes\",\n            RefuseText = \"No\",\n            WindowStartupLocation = System.Windows.WindowStartupLocation.CenterScreen,\n        };\n\n        var t = box.ShowDialogAsync();\n\n        return t;\n    });\n\n    await Task.Run(() =&gt;\n    {\n        if (result == System.Windows.MessageBoxResult.Yes)\n        {\n            Messenger.Send(\"I'm OK here.\", nameof(MainViewModel));\n        }\n        else if (result == System.Windows.MessageBoxResult.No)\n        {\n            Messenger.Send(\"Cancelled.\", nameof(MainViewModel));\n        }\n    });\n}\n</code></pre>","path":["WPF","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_2","level":2,"title":"理解","text":"<p>编译器对 <code>await</code> 的操作是将其后的代码片段转换成类似 <code>Task.Continuation</code> 的逻辑，本质上也是一种类似回调的逻辑，只不过是隐式由编译器实现的。</p> <p><code>base.ShowDialog</code> -&gt; 窗口关闭时返回 -&gt; 在 <code>OnClosing</code> 或 <code>OnButtonClick</code> 中设置结果 -&gt; <code>TaskCompletionSource.Task get</code> -&gt; <code>ShowDialogAsync</code> 结束返回</p>","path":["WPF","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%20MessageBox/#_3","level":2,"title":"代码","text":"<p>Github: CustomizedMessageBox</p>","path":["WPF","自定义 MessageBox"],"tags":["WPF","Frontend"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/","level":1,"title":"自定义组件","text":"<ul> <li>UserControl：适用于粒度较大，需要自己的 ViewModel 的组件；</li> <li>Custom Control：适用于粒度小，无额外状态或状态较少的组件；</li> </ul>","path":["WPF","自定义组件"],"tags":["WPF","Frontend"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/#usercontrol","level":2,"title":"UserControl","text":"<ul> <li>形式上是 .xaml.cs + .xaml；</li> <li>多个组件的组合，一般用于页面内容（或者用 Page）；</li> <li>一般有自己对应的 viewModel；</li> </ul> <p>总的来说适用于粒度比较大，其中引用多个无状态组件，但是自己本身有状态（viewModel）的组件情况。</p> <p>实现步骤：</p> <ol> <li>创建 UserControl（.xaml.cs, .xaml 文件）；</li> <li>创建对应的 ViewModel；</li> <li>在 ViewModel 中声明用于绑定的属性；</li> <li>在 .xaml 中进行绑定；</li> </ol> <p>如果情况比较简单，不使用 ViewModel，也可以在 .xaml.cs 中声明依赖属性，将 DataContext 设为控件自己。</p> <p>使用依赖属性时，如果仅有一个“主属性”，其它属性都是由主属性计算得来，那么在声明依赖属性时，利用 PropertyMetadata 中的 onPropertyChanged 回调进行其它依赖于它的属性的计算即可。</p>","path":["WPF","自定义组件"],"tags":["WPF","Frontend"]},{"location":"WPF/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/#custom-control","level":2,"title":"Custom control","text":"<ol> <li>可以直接手动创建 .cs 文件，继承 System.Windows.Controls.Control（不需要 .xaml 文件了）;</li> <li> <p>声明组件的 Style（对于控件样式使用 TemplateBinding，对于自定义的依赖属性，使用 Binding）；     <pre><code>&lt;Style TargetType=\"{x:Type local:MyCustomControl}\"&gt;\n    &lt;Setter Property=\"Template\"&gt;\n        &lt;Setter.Value&gt;\n            &lt;ControlTemplate TargetType=\"{x:Type local:MyCustomControl}\"&gt;\n                &lt;Border Padding=\"10\" Background=\"LightGray\"&gt;\n                    &lt;TextBlock Text=\"{TemplateBinding Title}\" FontSize=\"16\"/&gt;\n                &lt;/Border&gt;\n            &lt;/ControlTemplate&gt;\n        &lt;/Setter.Value&gt;\n    &lt;/Setter&gt;\n&lt;/Style&gt;\n</code></pre></p> </li> <li> <p>在 App.xaml 中（或者所需控件中）添加相关控件所在的资源字典；</p> </li> </ol>","path":["WPF","自定义组件"],"tags":["WPF","Frontend"]},{"location":"%E5%B7%A5%E5%85%B7/Code%20snippet/VS%20C%23%20partial%20property/","level":1,"title":"VS C# partial property","text":"<p>tags:     - Tools     - Code     - VisualStudio icon: fontawesome/solid/file-code</p> <p>用于 <code>CommunityToolkit.Mvvm</code> 的 partial property Code Snippet。</p>","path":["工具","Code snippet","VS C# partial property"],"tags":[]},{"location":"%E5%B7%A5%E5%85%B7/Code%20snippet/VS%20C%23%20partial%20property/#code-snippet","level":2,"title":"Code Snippet","text":"<p>文件路径：<code>%USERPROFILE%\\Documents\\Visual Studio 2022\\Code Snippets\\Visual C#\\My Code Snippets</code></p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;CodeSnippets xmlns=\"http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet\"&gt;\n    &lt;CodeSnippet Format=\"1.0.0\"&gt;\n        &lt;Header&gt;\n            &lt;Title&gt;propp&lt;/Title&gt;\n            &lt;Shortcut&gt;propp&lt;/Shortcut&gt;\n            &lt;Description&gt;Partial public property&lt;/Description&gt;\n            &lt;Author&gt;Orrest&lt;/Author&gt;\n        &lt;/Header&gt;\n        &lt;Snippet&gt;\n            &lt;Declarations&gt;\n                &lt;Literal&gt;\n                    &lt;ID&gt;type&lt;/ID&gt;\n                    &lt;ToolTip&gt;type&lt;/ToolTip&gt;\n                    &lt;Default&gt;Type&lt;/Default&gt;\n                &lt;/Literal&gt;\n                &lt;Literal&gt;\n                    &lt;ID&gt;prop&lt;/ID&gt;\n                    &lt;ToolTip&gt;Property name&lt;/ToolTip&gt;\n                    &lt;Default&gt;MyProperty&lt;/Default&gt;\n                &lt;/Literal&gt;\n            &lt;/Declarations&gt;\n            &lt;Code Language=\"csharp\"&gt;\n                &lt;![CDATA[\n[ObservableProperty]\npublic partial $type$ $prop$ { get; set; }\n        ]]&gt;\n            &lt;/Code&gt;\n        &lt;/Snippet&gt;\n    &lt;/CodeSnippet&gt;\n&lt;/CodeSnippets&gt;\n</code></pre>","path":["工具","Code snippet","VS C# partial property"],"tags":[]},{"location":"%E5%B7%A5%E5%85%B7/Code%20snippet/VS%20C%23%20partial%20property/#ref","level":2,"title":"Ref","text":"<p>Walkthrough: Create a code snippet in Visual Studio</p>","path":["工具","Code snippet","VS C# partial property"],"tags":[]},{"location":"%E5%B7%A5%E5%85%B7/Git/%E5%90%88%E5%B9%B6%E6%9C%80%E8%BF%91%E7%9A%84%E6%8F%90%E4%BA%A4/","level":1,"title":"合并最近的提交","text":"<p>一般都会从主分支拉自己的分支，然后进行修改。</p> <p>有时候会出现，已经推送到远程了一个版本，但是又要继续修改。</p> <p>如果再推送的话，远程就会有两笔分支，这两笔一个是 feature，一个是 fix。</p> <p>在第一笔还未合并到主分支的情况下，可以 squash 这两笔提交，让提交记录简洁一些。</p>","path":["工具","Git","合并最近的提交"],"tags":["Tools","Git","rebase"]},{"location":"%E5%B7%A5%E5%85%B7/Git/%E5%90%88%E5%B9%B6%E6%9C%80%E8%BF%91%E7%9A%84%E6%8F%90%E4%BA%A4/#_1","level":2,"title":"合并提交","text":"<pre><code>git rebase -i HEAD~2\n</code></pre> <ul> <li><code>HEAD~2</code> 合并最近的两笔</li> </ul> <pre><code>pick 4d7d0b8 Implement feature A\npick a3f9c21 Fix bug B\n</code></pre> <ul> <li>将第二行改为 squash</li> </ul> <pre><code>pick 4d7d0b8 Implement feature A\nsquash a3f9c21 Fix bug B\n</code></pre> <ul> <li>保存并关闭</li> </ul> <pre><code># This is a combination of 2 commits.\nImplement feature A\nFix bug B\n</code></pre> <ul> <li>修改提交信息，把两笔提交的消息合并成一个</li> </ul>","path":["工具","Git","合并最近的提交"],"tags":["Tools","Git","rebase"]},{"location":"%E5%B7%A5%E5%85%B7/Git/%E5%90%88%E5%B9%B6%E6%9C%80%E8%BF%91%E7%9A%84%E6%8F%90%E4%BA%A4/#_2","level":2,"title":"强制推送","text":"<p>如果第一笔历史已经推送到远程，并且是个人独立的工作分支，可以强制推送进行覆盖</p> <pre><code>git push --force-with-lease\n</code></pre>","path":["工具","Git","合并最近的提交"],"tags":["Tools","Git","rebase"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/","level":1,"title":"表示“转换”的单词","text":"","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#words","level":2,"title":"Words","text":"","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#convey","level":3,"title":"Convey","text":"<p>及物动词</p> <ul> <li>让某人知道或领会其他人的感情或想法；</li> <li>把人或者物从一个地方运输到另一处；</li> <li>【法律】将房屋产权或资产从一方转让给另一方；</li> </ul> <p>Please <code>convey</code> our condolences to the family. 请向家人表达我们的哀悼。</p> <p>An irrigation system was built to <code>convey</code> water from the river to the rice fields high up in the mountain. 通过灌溉系统，将水从河流输送到高山上的稻田。</p> <p>Mr Wu <code>conveyed</code> his entire estate to a charity. 吴先生把他所有的资产转给了一个慈善机构。</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#convert","level":3,"title":"Convert","text":"<p>及物动词/名词</p> <ul> <li>v. 转换、改变、改装，如单位转换；</li> <li>v. 思想或信仰的改变；</li> <li>n. 指改变了信仰的人；</li> </ul> <p>We need more space in the house, is it possible to <code>convert</code> the garage <code>into</code> a bedroom? 我们需要更多的空间，可不可以把车库改成一个卧房？</p> <p>I wasn’t interested in Korean dramas before, but my cousin has <code>converted</code> me. 我以前对韩剧没什么兴趣，不过我的表妹改变了我的看法。</p> <p>I wasn’t convinced about dishwashers, but now I am a <code>convert</code>. 我以前不相信洗碗机有什么用，但是现在我彻底转变想法了 。</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#transform","level":3,"title":"Transform","text":"<p>一般是及物动词</p> <ul> <li>完全地、彻底地改变一个人或一个事物的外表或性质（一般是向好的方面）；</li> </ul> <p>The plan is to <code>transform</code> the area <code>into</code> a tourist attraction. 这个计划是把这个地区开发成一个旅游景点。</p> <p>In the film, a plain young girl was <code>transformed</code> <code>into</code> a star. 在电影里，一名普通的女孩儿摇身一变成了明星。</p> <p>Smartphone technology has <code>transformed</code> the way we communicate with each other. 智能手机技术完全改变了人们交流的方式。</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#divert","level":3,"title":"Divert","text":"<ul> <li>使事物或人转变方向；</li> <li>改变事物的用途；</li> <li>转移或分散注意力；</li> <li>提供娱乐（很少使用）；</li> </ul> <p>Due to fog, our plane was <code>diverted</code> to another airport. 受大雾影响，我们的飞机被转到了另一个机场。</p> <p>The telecom companies have set very high charges for <code>diverting</code> international calls. 电话公司设定了非常高的国际电话转接费。</p> <p>It’s against law to <code>divert</code> public funds for private use. 挪用公款来支付个人开支是违法行为。</p> <p>The directors tried to <code>divert</code> attention away from the real issues in the work place. 公司领导试图把大家的注意力从公司里实际的问题上转移。</p> <p>The kids managed to <code>divert</code> themselves with a set of DVDs. 小朋友们找到了一些 DVD 碟片，可以自我娱乐了。</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]},{"location":"%E8%8B%B1%E8%AF%AD/%E8%A1%A8%E7%A4%BA%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D%E7%9A%84%E5%8D%95%E8%AF%8D/#ref","level":2,"title":"Ref","text":"<p>Convey, convert, transform 和 divert 四个含有“转换”意思的单词</p>","path":["英语","表示“转换”的单词"],"tags":["English","Word"]}]}